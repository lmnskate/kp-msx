<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subtitle Sync</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.6.11/dist/hls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 10px;
        }

        .content {
            padding: 30px;
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border: 1px solid #f0f0f0;
        }

        .section.hidden {
            display: none;
        }

        .section h2 {
            color: #2c3e50;
            font-size: 1.4rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2:before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #3498db, #2c3e50);
            border-radius: 2px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
            font-size: 0.95rem;
        }

        .input-row {
            display: flex;
            gap: 15px;
            align-items: end;
        }

        input[type="text"], input[type="number"], input[type="file"], select {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        }

        .btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .btn-success:hover {
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }

        #videoContainer {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        #videoPlayer {
            width: 100%;
            max-height: 60vh;
            border-radius: 15px;
            background: #000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: block;
        }

        #videoPlayer::cue {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .selection-btn {
            padding: 12px 16px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-size: 0.9rem;
        }

        .selection-btn:hover {
            border-color: #3498db;
            background: #f0f8ff;
        }

        .selection-btn.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        .selection-btn.selected:hover {
            background: #2980b9;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .status-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }

        .status {
            padding: 15px 20px;
            margin-bottom: 10px;
            border-radius: 10px;
            font-size: 0.9rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .status.success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
        }

        .status.error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .status.info {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .subtitle-info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .hint {
            font-size: 0.85rem;
            color: #7f8c8d;
            margin-top: 5px;
            font-style: italic;
        }

        @media (max-width: 768px) {
            body { padding: 10px; }
            .header { padding: 20px; }
            .header h1 { font-size: 2rem; }
            .content { padding: 20px; }
            .section { padding: 20px; }
            .controls-grid { grid-template-columns: 1fr; }
            .input-row { flex-direction: column; align-items: stretch; }
            .selection-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>Subtitle Sync</h1>
        </div>

        <div class="content">
            <!-- Content Loading Section -->
            <div class="section" id="contentLoadingSection">
                <h2>üé¨ Content Loading</h2>
                <div class="form-group">
                    <label for="clientId">Client ID</label>
                    <div class="input-row">
                        <input type="text" id="clientId" placeholder="Enter your client ID">
                    </div>
                </div>
                <div class="form-group">
                    <label for="contentInput">Content ID or URL</label>
                    <div class="input-row">
                        <input type="text" id="contentInput" placeholder="707 or https://example.com/item/view/707/">
                        <button class="btn" onclick="loadContent()">Load Content</button>
                    </div>
                    <div class="hint">Enter a content ID (like 707) or full URL to load available streams</div>
                </div>
            </div>

            <!-- Video Selection Section (for multi-video content) -->
            <div class="section hidden" id="videoSelectionSection">
                <h2>üìÅ Select Version</h2>
                <div class="selection-grid" id="videoSelectionGrid"></div>
            </div>

            <!-- Season Selection Section -->
            <div class="section hidden" id="seasonSelectionSection">
                <h2>üì∫ Select Season</h2>
                <div class="selection-grid" id="seasonSelectionGrid"></div>
            </div>

            <!-- Episode Selection Section -->
            <div class="section hidden" id="episodeSelectionSection">
                <h2>üé¨ Select Episode</h2>
                <div class="selection-grid" id="episodeSelectionGrid"></div>
            </div>

            <!-- Audio Track & Subtitle File Section -->
            <div class="section" id="audioSubtitleSection">
                <h2>üîä Audio & Subtitles</h2>
                <div class="form-group">
                    <label for="audioTrackSelect">Audio Track</label>
                    <select id="audioTrackSelect" onchange="changeAudioTrack()">
                        <option value="">No audio tracks available</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="srtFile">SRT Subtitle File</label>
                    <input type="file" id="srtFile" accept=".srt" onchange="loadSrtFile()">
                    <div class="hint">Upload an SRT file to add subtitles with timing controls</div>
                </div>
            </div>

            <!-- Video Player Section -->
            <div class="section" id="videoPlayerSection">
                <h2>üì∫ Video Player</h2>
                <div id="videoContainer">
                    <video id="videoPlayer" controls crossorigin="anonymous">
                        Your browser does not support the video tag.
                    </video>
                </div>
            </div>

            <!-- Subtitle Controls Section -->
            <div class="section" id="subtitleControlsSection">
                <h2>‚öôÔ∏è Subtitle Timing Controls</h2>
                <div class="controls-grid">
                    <div class="form-group">
                        <label for="timeShift">Time Shift (seconds)</label>
                        <input type="number" id="timeShift" value="0" step="0.1" placeholder="0">
                        <div class="hint">Positive = later, Negative = earlier</div>
                    </div>
                    <div class="form-group">
                        <label for="timeMultiplier">Speed Multiplier</label>
                        <input type="number" id="timeMultiplier" value="1.0" step="0.001" placeholder="1.0">
                        <div class="hint">1.0 = normal, 0.9 = 10% faster, 1.1 = 10% slower</div>
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn" onclick="applyAllCorrections()">Apply Changes</button>
                    <button class="btn btn-secondary" onclick="resetSubtitles()">Reset</button>
                    <button class="btn btn-secondary" onclick="toggleSubtitles()">Toggle Subtitles</button>
                    <button class="btn btn-success" id="downloadBtn" onclick="downloadSubtitles()" disabled>Download SRT</button>
                </div>

                <div id="subtitleInfo" class="subtitle-info">
                    No subtitles loaded
                </div>
            </div>
        </div>
    </div>

    <!-- Status Messages Container -->
    <div id="statusContainer" class="status-container"></div>

    <script>
        // Global variables
        let hls;
        let originalSubtitles = [];
        let currentSubtitles = [];
        let originalFileName = 'subtitles';
        let currentContentId = null;
        let currentClientId = null;
        let currentTextTrack = null;
        let lastSelectedAudioTrack = -1;

        // DOM elements
        const video = document.getElementById('videoPlayer');
        const audioTrackSelect = document.getElementById('audioTrackSelect');

        // Section management
        function showSection(sectionId) {
            document.getElementById(sectionId).classList.remove('hidden');
        }

        function hideSection(sectionId) {
            document.getElementById(sectionId).classList.add('hidden');
        }

        function hideAllSelectionSections() {
            hideSection('videoSelectionSection');
            hideSection('seasonSelectionSection');
            hideSection('episodeSelectionSection');
        }

        function clearSelectionGrid(gridId) {
            document.getElementById(gridId).innerHTML = '';
        }

        function selectButton(gridId, buttonIndex) {
            const buttons = document.querySelectorAll(`#${gridId} .selection-btn`);
            buttons.forEach(btn => btn.classList.remove('selected'));
            if (buttons[buttonIndex]) {
                buttons[buttonIndex].classList.add('selected');
            }
        }

        // Utility functions
        function showStatus(message, type = 'info') {
            const container = document.getElementById('statusContainer');
            const statusEl = document.createElement('div');
            statusEl.className = `status ${type}`;
            statusEl.textContent = message;
            container.appendChild(statusEl);

            setTimeout(() => {
                if (statusEl.parentNode) {
                    statusEl.parentNode.removeChild(statusEl);
                }
            }, 5000);
        }

        function parseContentId(input) {
            if (/^\d+$/.test(input.trim())) {
                return input.trim();
            }
            const urlMatch = input.match(/\/item\/view\/(\d+)/);
            return urlMatch ? urlMatch[1] : null;
        }

        // Content loading functions
        async function loadContent() {
            const clientId = document.getElementById('clientId').value.trim();
            const contentInput = document.getElementById('contentInput').value.trim();

            if (!clientId || !contentInput) {
                showStatus('Please enter both Client ID and Content ID/URL', 'error');
                return;
            }

            const contentId = parseContentId(contentInput);
            if (!contentId) {
                showStatus('Invalid Content ID or URL format', 'error');
                return;
            }

            currentClientId = clientId;
            currentContentId = contentId;

            try {
                showStatus('Loading content...', 'info');
                hideAllSelectionSections();

                const response = await fetch(`/msx/content?id=${clientId}&content_id=${contentId}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                processContentResponse(data);

            } catch (error) {
                showStatus(`Failed to load content: ${error.message}`, 'error');
            }
        }

        function processContentResponse(data) {
            let watchButton = null;

            if (data.pages) {
                for (const page of data.pages) {
                    if (page.items) {
                        const found = page.items.find(item => item.id === 'watch_button');
                        if (found) {
                            watchButton = found;
                            break;
                        }
                    }
                }
            }

            if (!watchButton?.action) {
                showStatus('No watch button found', 'error');
                return;
            }

            showStatus(`Loaded: ${data.headline || 'Unknown'}`, 'success');

            const action = watchButton.action;
            if (action.startsWith('video:plugin:')) {
                const urlMatch = action.match(/url=([^&]+)/);
                if (urlMatch) {
                    loadStream(decodeURIComponent(urlMatch[1]));
                }
            } else if (action.includes('/msx/multivideo')) {
                loadMultiVideo();
            } else if (action.includes('/msx/seasons')) {
                loadSeasons();
            }
        }

        async function loadMultiVideo() {
            try {
                const response = await fetch(`/msx/multivideo?id=${currentClientId}&content_id=${currentContentId}`);
                const data = await response.json();
                showVideoOptions(data);
            } catch (error) {
                showStatus(`Failed to load video options: ${error.message}`, 'error');
            }
        }

        function showVideoOptions(data) {
            hideAllSelectionSections();
            clearSelectionGrid('videoSelectionGrid');

            data.items.forEach((item, index) => {
                const button = document.createElement('button');
                button.className = 'selection-btn';
                button.textContent = item.label;
                button.onclick = () => selectVideo(item.action, index);
                document.getElementById('videoSelectionGrid').appendChild(button);
            });

            showSection('videoSelectionSection');
        }

        function selectVideo(action, buttonIndex) {
            selectButton('videoSelectionGrid', buttonIndex);

            const urlMatch = action.match(/url=([^&]+)/);
            if (urlMatch) {
                resetSubtitleOffsets();
                loadStream(decodeURIComponent(urlMatch[1]));
            }
        }

        async function loadSeasons() {
            try {
                const response = await fetch(`/msx/seasons?id=${currentClientId}&content_id=${currentContentId}`);
                const data = await response.json();
                showSeasons(data);
            } catch (error) {
                showStatus(`Failed to load seasons: ${error.message}`, 'error');
            }
        }

        function showSeasons(data) {
            hideAllSelectionSections();
            clearSelectionGrid('seasonSelectionGrid');

            data.items.forEach((item, index) => {
                const seasonMatch = item.action.match(/season=(\d+)/);
                const season = seasonMatch ? seasonMatch[1] : index + 1;

                const button = document.createElement('button');
                button.className = 'selection-btn';
                button.textContent = item.label;
                button.onclick = () => selectSeason(season, index);
                document.getElementById('seasonSelectionGrid').appendChild(button);
            });

            showSection('seasonSelectionSection');
        }

        function selectSeason(season, buttonIndex) {
            selectButton('seasonSelectionGrid', buttonIndex);
            loadEpisodes(season);
        }

        async function loadEpisodes(season) {
            try {
                const response = await fetch(`/msx/episodes?id=${currentClientId}&content_id=${currentContentId}&season=${season}`);
                const data = await response.json();
                showEpisodes(data);
            } catch (error) {
                showStatus(`Failed to load episodes: ${error.message}`, 'error');
            }
        }

        function showEpisodes(data) {
            clearSelectionGrid('episodeSelectionGrid');

            data.items.forEach((item, index) => {
                const button = document.createElement('button');
                button.className = 'selection-btn';
                button.textContent = item.label;
                button.onclick = () => selectEpisode(item.action, index);
                document.getElementById('episodeSelectionGrid').appendChild(button);
            });

            showSection('episodeSelectionSection');
        }

        function selectEpisode(action, buttonIndex) {
            selectButton('episodeSelectionGrid', buttonIndex);

            const urlMatch = action.match(/url=([^&]+)/);
            if (urlMatch) {
                resetSubtitleOffsets();
                loadStream(decodeURIComponent(urlMatch[1]));
            }
        }

        function resetSubtitleOffsets() {
            document.getElementById('timeShift').value = '0';
            document.getElementById('timeMultiplier').value = '1.0';

            if (originalSubtitles.length > 0) {
                currentSubtitles = [...originalSubtitles];
                applySubtitlesToVideo();
            }
        }

        // Video loading and HLS functions
        function loadStream(streamUrl) {
            if (!streamUrl) {
                showStatus('No stream URL provided', 'error');
                return;
            }

            if (hls) hls.destroy();

            if (Hls.isSupported()) {
                hls = new Hls({ debug: false });
                hls.loadSource(streamUrl);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    showStatus('Stream loaded successfully', 'success');
                    setTimeout(loadAudioTracks, 100);
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        showStatus(`Stream error: ${data.details}`, 'error');
                    }
                });
            } else {
                showStatus('HLS not supported in this browser', 'error');
            }
        }

        function loadAudioTracks() {
            audioTrackSelect.innerHTML = '<option value="">Select audio track</option>';

            if (hls && hls.audioTracks && hls.audioTracks.length > 0) {
                hls.audioTracks.forEach((track, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${track.name || `Track ${index + 1}`} (${track.lang || 'Unknown'})`;
                    audioTrackSelect.appendChild(option);
                });

                // Restore previously selected audio track
                if (lastSelectedAudioTrack >= 0 && lastSelectedAudioTrack < hls.audioTracks.length) {
                    audioTrackSelect.value = lastSelectedAudioTrack;
                    hls.audioTrack = lastSelectedAudioTrack;
                    showStatus(`Restored audio track ${lastSelectedAudioTrack + 1}`, 'info');
                } else {
                    showStatus(`Found ${hls.audioTracks.length} audio tracks`, 'info');
                }
            } else {
                audioTrackSelect.innerHTML = '<option value="">No audio tracks available</option>';
            }
        }

        function changeAudioTrack() {
            const selectedTrack = audioTrackSelect.value;
            if (hls && selectedTrack !== '') {
                const trackIndex = parseInt(selectedTrack);
                hls.audioTrack = trackIndex;
                lastSelectedAudioTrack = trackIndex;
                showStatus(`Switched to audio track ${trackIndex + 1}`, 'success');
            }
        }

        // Subtitle functions
        function loadSrtFile() {
            const file = document.getElementById('srtFile').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                originalSubtitles = parseSRT(e.target.result);
                currentSubtitles = [...originalSubtitles];
                originalFileName = file.name.replace('.srt', '');
                applySubtitlesToVideo();

                document.getElementById('subtitleInfo').textContent =
                    `Loaded ${originalSubtitles.length} subtitle entries from ${file.name}`;
                showStatus(`SRT loaded: ${originalSubtitles.length} entries`, 'success');

                document.getElementById('downloadBtn').disabled = false;
            };
            reader.readAsText(file);
        }

        function parseSRT(srtContent) {
            const entries = [];
            const blocks = srtContent.trim().split(/\n\s*\n/);

            blocks.forEach(block => {
                const lines = block.split('\n');
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timecode = lines[1];
                    const text = lines.slice(2).join('\n');
                    const [start, end] = timecode.split(' --> ');

                    entries.push({
                        index: index,
                        start: timeToSeconds(start),
                        end: timeToSeconds(end),
                        text: text
                    });
                }
            });

            return entries;
        }

        function timeToSeconds(timeString) {
            const parts = timeString.replace(',', '.').split(':');
            return parseFloat(parts[0]) * 3600 + parseFloat(parts[1]) * 60 + parseFloat(parts[2]);
        }

        function secondsToTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.padStart(6, '0').replace('.', ',')}`;
        }

        function generateSRT(subtitles) {
            return subtitles.map(entry =>
                `${entry.index}\n${secondsToTime(entry.start)} --> ${secondsToTime(entry.end)}\n${entry.text}\n`
            ).join('\n');
        }

        function convertSrtToWebVTT(subtitles) {
            let vttContent = 'WEBVTT\n\n';

            subtitles.forEach((subtitle, index) => {
                const cueId = `cue-${index}`;
                const startTime = formatWebVTTTime(subtitle.start);
                const endTime = formatWebVTTTime(subtitle.end);
                const text = subtitle.text.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n');

                vttContent += `${cueId}\n${startTime} --> ${endTime}\n${text}\n\n`;
            });

            return vttContent;
        }

        function formatWebVTTTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            const h = hours.toString().padStart(2, '0');
            const m = minutes.toString().padStart(2, '0');
            const s = secs.toFixed(3).padStart(6, '0');

            return `${h}:${m}:${s}`;
        }

        function applySubtitlesToVideo() {
            if (currentSubtitles.length === 0) {
                clearExistingTextTracks();
                return;
            }

            clearExistingTextTracks();

            const vttContent = convertSrtToWebVTT(currentSubtitles);
            const vttBlob = new Blob([vttContent], { type: 'text/vtt' });
            const vttUrl = URL.createObjectURL(vttBlob);

            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.src = vttUrl;
            track.srclang = 'en';
            track.label = 'External Subtitles';
            track.default = true;

            video.appendChild(track);

            track.addEventListener('load', () => {
                const textTrack = track.track;
                if (textTrack) {
                    textTrack.mode = 'showing';
                    currentTextTrack = textTrack;
                    showStatus('Subtitles loaded successfully', 'success');
                }
            });

            track.addEventListener('error', () => {
                showStatus('Failed to load subtitles', 'error');
            });
        }

        function clearExistingTextTracks() {
            const tracks = video.querySelectorAll('track');
            tracks.forEach(track => track.remove());

            for (let i = 0; i < video.textTracks.length; i++) {
                video.textTracks[i].mode = 'disabled';
            }

            currentTextTrack = null;
        }

        function applyAllCorrections() {
            if (originalSubtitles.length === 0) {
                showStatus('No subtitles loaded', 'error');
                return;
            }

            const shift = parseFloat(document.getElementById('timeShift').value) || 0;
            const multiplier = parseFloat(document.getElementById('timeMultiplier').value) || 1.0;

            if (multiplier <= 0) {
                showStatus('Multiplier must be greater than 0', 'error');
                return;
            }

            currentSubtitles = originalSubtitles.map(entry => ({
                ...entry,
                start: Math.max(0, (entry.start * multiplier) + shift),
                end: Math.max(0, (entry.end * multiplier) + shift)
            }));

            applySubtitlesToVideo();

            let statusParts = [];
            if (multiplier !== 1.0) {
                const changePercent = Math.round((multiplier - 1) * 100);
                const changeText = changePercent === 0 ? 'no change' :
                                   changePercent > 0 ? `${changePercent}% slower` :
                                   `${Math.abs(changePercent)}% faster`;
                statusParts.push(`Speed: ${multiplier}x (${changeText})`);
            }
            if (shift !== 0) {
                statusParts.push(`Shift: ${shift > 0 ? '+' : ''}${shift}s`);
            }

            showStatus(statusParts.length === 0 ? 'No changes applied' :
                      `Applied: ${statusParts.join(', ')}`, 'success');
        }

        function resetSubtitles() {
            if (originalSubtitles.length === 0) {
                showStatus('No subtitles loaded', 'error');
                return;
            }

            currentSubtitles = [...originalSubtitles];
            applySubtitlesToVideo();

            document.getElementById('timeShift').value = '0';
            document.getElementById('timeMultiplier').value = '1.0';

            showStatus('Subtitles reset to original', 'success');
        }

        function toggleSubtitles() {
            if (currentTextTrack) {
                const isShowing = currentTextTrack.mode === 'showing';
                currentTextTrack.mode = isShowing ? 'hidden' : 'showing';
                showStatus(`Subtitles ${isShowing ? 'hidden' : 'shown'}`, 'info');
            } else if (video.textTracks.length > 0) {
                const track = video.textTracks[0];
                const isShowing = track.mode === 'showing';
                track.mode = isShowing ? 'hidden' : 'showing';
                showStatus(`Subtitles ${isShowing ? 'hidden' : 'shown'}`, 'info');
            } else {
                showStatus('No subtitle tracks available', 'error');
            }
        }

        function downloadSubtitles() {
            if (currentSubtitles.length === 0) {
                showStatus('No subtitles to download', 'error');
                return;
            }

            const shift = parseFloat(document.getElementById('timeShift').value) || 0;
            const multiplier = parseFloat(document.getElementById('timeMultiplier').value) || 1.0;

            let suffix = '';
            if (shift !== 0 || multiplier !== 1.0) {
                let corrections = [];
                if (multiplier !== 1.0) corrections.push(`x${multiplier}`);
                if (shift !== 0) corrections.push(`${shift > 0 ? '+' : ''}${shift}s`);
                suffix = '_' + corrections.join('_');
            }

            const filename = `${originalFileName}${suffix}.srt`;
            const blob = new Blob([generateSRT(currentSubtitles)], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`Downloaded: ${filename}`, 'success');
        }

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (hls) hls.destroy();
            clearExistingTextTracks();
        });
    </script>
</body>
</html>